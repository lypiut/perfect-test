/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: geobuf.proto
 *
 */

import Foundation
import SwiftProtobuf


public struct Geojson: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Geojson"}
  public var protoMessageName: String {return "Geojson"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "keys": 1,
    "dimensions": 2,
    "precision": 3,
    "featureCollection": 4,
    "feature": 5,
    "geometry": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "keys": 1,
    "dimensions": 2,
    "precision": 3,
    "feature_collection": 4,
    "feature": 5,
    "geometry": 6,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Geojson
    var unknown = ProtobufUnknownStorage()
    var _keys: [String] = []
    var _dimensions: UInt32? = nil
    var _precision: UInt32? = nil
    var _dataType = Geojson.OneOf_DataType()

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_keys)
      case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_dimensions)
      case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_precision)
      case 4, 5, 6:
        handled = try _dataType.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if !_keys.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _keys, protoFieldNumber: 1, protoFieldName: "keys", jsonFieldName: "keys", swiftFieldName: "keys")
      }
      if let v = _dimensions {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "dimensions", jsonFieldName: "dimensions", swiftFieldName: "dimensions")
      }
      if let v = _precision {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "precision", jsonFieldName: "precision", swiftFieldName: "precision")
      }
      try _dataType.traverse(visitor: &visitor, start: 4, end: 7)
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _keys != other._keys {return false}
      if (((_dimensions != nil && _dimensions! != 2) || (other._dimensions != nil && other._dimensions! != 2)) && (_dimensions == nil || other._dimensions == nil || _dimensions! != other._dimensions!)) {return false}
      if (((_precision != nil && _precision! != 6) || (other._precision != nil && other._precision! != 6)) && (_precision == nil || other._precision == nil || _precision! != other._precision!)) {return false}
      if _dataType != other._dataType {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._keys = _keys
      clone._dimensions = _dimensions
      clone._precision = _precision
      clone._dataType = _dataType
      return clone
    }
  }

  private var _storage = _StorageClass()

  public enum OneOf_DataType: ExpressibleByNilLiteral, ProtobufOneofEnum {
    case featureCollection(Geojson.FeatureCollection)
    case feature(Geojson.Feature)
    case geometry(Geojson.Geometry)
    case None

    public init(nilLiteral: ()) {
      self = .None
    }

    public init() {
      self = .None
    }

    public mutating func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      if self != .None && setter.rejectConflictingOneof {
        throw ProtobufDecodingError.duplicatedOneOf
      }
      let handled: Bool
      switch protoFieldNumber {
      case 4:
        var value: Geojson.FeatureCollection?
        handled = try setter.decodeOptionalMessageField(fieldType: Geojson.FeatureCollection.self, value: &value)
        if let value = value, handled {
          self = .featureCollection(value)
        }
      case 5:
        var value: Geojson.Feature?
        handled = try setter.decodeOptionalMessageField(fieldType: Geojson.Feature.self, value: &value)
        if let value = value, handled {
          self = .feature(value)
        }
      case 6:
        var value: Geojson.Geometry?
        handled = try setter.decodeOptionalMessageField(fieldType: Geojson.Geometry.self, value: &value)
        if let value = value, handled {
          self = .geometry(value)
        }
      default:
        handled = false
        self = .None
      }
      return handled
    }

    public func traverse(visitor: inout ProtobufVisitor, start: Int, end: Int) throws {
      switch self {
      case .featureCollection(let v):
        if start <= 4 && 4 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "feature_collection", jsonFieldName: "featureCollection", swiftFieldName: "featureCollection")
        }
      case .feature(let v):
        if start <= 5 && 5 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 5, protoFieldName: "feature", jsonFieldName: "feature", swiftFieldName: "feature")
        }
      case .geometry(let v):
        if start <= 6 && 6 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 6, protoFieldName: "geometry", jsonFieldName: "geometry", swiftFieldName: "geometry")
        }
      case .None:
        break
      }
    }
  }

  public struct Feature: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Geojson.Feature"}
    public var protoMessageName: String {return "Feature"}
    public var protoPackageName: String {return ""}
    public var jsonFieldNames: [String: Int] {return [
      "geometry": 1,
      "id": 11,
      "intId": 12,
      "values": 13,
      "properties": 14,
      "customProperties": 15,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "geometry": 1,
      "id": 11,
      "int_id": 12,
      "values": 13,
      "properties": 14,
      "custom_properties": 15,
    ]}

    private class _StorageClass {
      typealias ProtobufExtendedMessage = Geojson.Feature
      var unknown = ProtobufUnknownStorage()
      var _geometry: Geojson.Geometry? = nil
      var _idType = Geojson.Feature.OneOf_IdType()
      var _values: [Geojson.Value] = []
      var _properties: [UInt32] = []
      var _customProperties: [UInt32] = []

      init() {}

      func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        let handled: Bool
        switch protoFieldNumber {
        case 1: handled = try setter.decodeRequiredMessageField(fieldType: Geojson.Geometry.self, value: &_geometry)
        case 11, 12:
          handled = try _idType.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
        case 13: handled = try setter.decodeRepeatedMessageField(fieldType: Geojson.Value.self, value: &_values)
        case 14: handled = try setter.decodePackedField(fieldType: ProtobufUInt32.self, value: &_properties)
        case 15: handled = try setter.decodePackedField(fieldType: ProtobufUInt32.self, value: &_customProperties)
        default:
          handled = false
        }
        if handled {
            return true
        } else {
            return try unknown.decodeField(setter: &setter)
        }
      }

      func traverse(visitor: inout ProtobufVisitor) throws {
        if let v = _geometry {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "geometry", jsonFieldName: "geometry", swiftFieldName: "geometry")
        }
        try _idType.traverse(visitor: &visitor, start: 11, end: 13)
        if !_values.isEmpty {
          try visitor.visitRepeatedMessageField(value: _values, protoFieldNumber: 13, protoFieldName: "values", jsonFieldName: "values", swiftFieldName: "values")
        }
        if !_properties.isEmpty {
          try visitor.visitPackedField(fieldType: ProtobufUInt32.self, value: _properties, protoFieldNumber: 14, protoFieldName: "properties", jsonFieldName: "properties", swiftFieldName: "properties")
        }
        if !_customProperties.isEmpty {
          try visitor.visitPackedField(fieldType: ProtobufUInt32.self, value: _customProperties, protoFieldNumber: 15, protoFieldName: "custom_properties", jsonFieldName: "customProperties", swiftFieldName: "customProperties")
        }
        unknown.traverse(visitor: &visitor)
      }

      func isEqualTo(other: _StorageClass) -> Bool {
        if _geometry != other._geometry {return false}
        if _idType != other._idType {return false}
        if _values != other._values {return false}
        if _properties != other._properties {return false}
        if _customProperties != other._customProperties {return false}
        if unknown != other.unknown {return false}
        return true
      }

      func copy() -> _StorageClass {
        let clone = _StorageClass()
        clone.unknown = unknown
        clone._geometry = _geometry
        clone._idType = _idType
        clone._values = _values
        clone._properties = _properties
        clone._customProperties = _customProperties
        return clone
      }
    }

    private var _storage = _StorageClass()

    public enum OneOf_IdType: ExpressibleByNilLiteral, ProtobufOneofEnum {
      case id(String)
      case intId(Int64)
      case None

      public init(nilLiteral: ()) {
        self = .None
      }

      public init() {
        self = .None
      }

      public mutating func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        if self != .None && setter.rejectConflictingOneof {
          throw ProtobufDecodingError.duplicatedOneOf
        }
        let handled: Bool
        switch protoFieldNumber {
        case 11:
          var value: String?
          handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &value)
          if let value = value, handled {
            self = .id(value)
          }
        case 12:
          var value: Int64?
          handled = try setter.decodeOptionalField(fieldType: ProtobufSInt64.self, value: &value)
          if let value = value, handled {
            self = .intId(value)
          }
        default:
          handled = false
          self = .None
        }
        return handled
      }

      public func traverse(visitor: inout ProtobufVisitor, start: Int, end: Int) throws {
        switch self {
        case .id(let v):
          if start <= 11 && 11 < end {
            try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 11, protoFieldName: "id", jsonFieldName: "id", swiftFieldName: "id")
          }
        case .intId(let v):
          if start <= 12 && 12 < end {
            try visitor.visitSingularField(fieldType: ProtobufSInt64.self, value: v, protoFieldNumber: 12, protoFieldName: "int_id", jsonFieldName: "intId", swiftFieldName: "intId")
          }
        case .None:
          break
        }
      }
    }

    public var geometry: Geojson.Geometry {
      get {return _storage._geometry ?? Geojson.Geometry()}
      set {_uniqueStorage()._geometry = newValue}
    }

    public var id: String? {
      get {
        if case .id(let v) = _storage._idType {
          return v
        }
        return nil
      }
      set {
        if let newValue = newValue {
          _uniqueStorage()._idType = .id(newValue)
        } else {
          _uniqueStorage()._idType = .None
        }
      }
    }

    public var intId: Int64? {
      get {
        if case .intId(let v) = _storage._idType {
          return v
        }
        return nil
      }
      set {
        if let newValue = newValue {
          _uniqueStorage()._idType = .intId(newValue)
        } else {
          _uniqueStorage()._idType = .None
        }
      }
    }

    ///   unique values
    public var values: [Geojson.Value] {
      get {return _storage._values}
      set {_uniqueStorage()._values = newValue}
    }

    ///   pairs of key/value indexes
    public var properties: [UInt32] {
      get {return _storage._properties}
      set {_uniqueStorage()._properties = newValue}
    }

    ///   arbitrary properties
    public var customProperties: [UInt32] {
      get {return _storage._customProperties}
      set {_uniqueStorage()._customProperties = newValue}
    }

    public var _idType: OneOf_IdType {
      get {return _storage._idType}
      set {
        _uniqueStorage()._idType = newValue
      }
    }

    public init() {}

    public init(geometry: Geojson.Geometry? = nil,
      id: String? = nil,
      intId: Int64? = nil,
      values: [Geojson.Value] = [],
      properties: [UInt32] = [],
      customProperties: [UInt32] = [])
    {
      let storage = _uniqueStorage()
      storage._geometry = geometry
      if let v = id {
        storage._idType = .id(v)
      }
      if let v = intId {
        storage._idType = .intId(v)
      }
      if !values.isEmpty {
        storage._values = values
      }
      if !properties.isEmpty {
        storage._properties = properties
      }
      if !customProperties.isEmpty {
        storage._customProperties = customProperties
      }
    }

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      try _storage.traverse(visitor: &visitor)
    }

    public func _protoc_generated_isEqualTo(other: Geojson.Feature) -> Bool {
      return _storage === other._storage || _storage.isEqualTo(other: other._storage)
    }

    private mutating func _uniqueStorage() -> _StorageClass {
      if !isKnownUniquelyReferenced(&_storage) {
        _storage = _storage.copy()
      }
      return _storage
    }
  }

  public struct Geometry: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Geojson.Geometry"}
    public var protoMessageName: String {return "Geometry"}
    public var protoPackageName: String {return ""}
    public var jsonFieldNames: [String: Int] {return [
      "type": 1,
      "lengths": 2,
      "coords": 3,
      "geometries": 4,
      "values": 13,
      "customProperties": 15,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "type": 1,
      "lengths": 2,
      "coords": 3,
      "geometries": 4,
      "values": 13,
      "custom_properties": 15,
    ]}

    var unknown = ProtobufUnknownStorage()

    public enum TypeEnum: ProtobufEnum {
      public typealias RawValue = Int
      case point // = 0
      case multipoint // = 1
      case linestring // = 2
      case multilinestring // = 3
      case polygon // = 4
      case multipolygon // = 5
      case geometrycollection // = 6

      public init() {
        self = .point
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .point
        case 1: self = .multipoint
        case 2: self = .linestring
        case 3: self = .multilinestring
        case 4: self = .polygon
        case 5: self = .multipolygon
        case 6: self = .geometrycollection
        default: return nil
        }
      }

      public init?(name: String) {
        switch name {
        case "point": self = .point
        case "multipoint": self = .multipoint
        case "linestring": self = .linestring
        case "multilinestring": self = .multilinestring
        case "polygon": self = .polygon
        case "multipolygon": self = .multipolygon
        case "geometrycollection": self = .geometrycollection
        default: return nil
        }
      }

      public init?(jsonName: String) {
        switch jsonName {
        case "POINT": self = .point
        case "MULTIPOINT": self = .multipoint
        case "LINESTRING": self = .linestring
        case "MULTILINESTRING": self = .multilinestring
        case "POLYGON": self = .polygon
        case "MULTIPOLYGON": self = .multipolygon
        case "GEOMETRYCOLLECTION": self = .geometrycollection
        default: return nil
        }
      }

      public init?(protoName: String) {
        switch protoName {
        case "POINT": self = .point
        case "MULTIPOINT": self = .multipoint
        case "LINESTRING": self = .linestring
        case "MULTILINESTRING": self = .multilinestring
        case "POLYGON": self = .polygon
        case "MULTIPOLYGON": self = .multipolygon
        case "GEOMETRYCOLLECTION": self = .geometrycollection
        default: return nil
        }
      }

      public var rawValue: Int {
        get {
          switch self {
          case .point: return 0
          case .multipoint: return 1
          case .linestring: return 2
          case .multilinestring: return 3
          case .polygon: return 4
          case .multipolygon: return 5
          case .geometrycollection: return 6
          }
        }
      }

      public var json: String {
        get {
          switch self {
          case .point: return "\"POINT\""
          case .multipoint: return "\"MULTIPOINT\""
          case .linestring: return "\"LINESTRING\""
          case .multilinestring: return "\"MULTILINESTRING\""
          case .polygon: return "\"POLYGON\""
          case .multipolygon: return "\"MULTIPOLYGON\""
          case .geometrycollection: return "\"GEOMETRYCOLLECTION\""
          }
        }
      }

      public var hashValue: Int { return rawValue }

      public var debugDescription: String {
        get {
          switch self {
          case .point: return ".point"
          case .multipoint: return ".multipoint"
          case .linestring: return ".linestring"
          case .multilinestring: return ".multilinestring"
          case .polygon: return ".polygon"
          case .multipolygon: return ".multipolygon"
          case .geometrycollection: return ".geometrycollection"
          }
        }
      }

    }

    public var type: Geojson.Geometry.TypeEnum = Geojson.Geometry.TypeEnum.point

    ///   coordinate structure in lengths
    public var lengths: [UInt32] = []

    ///   delta-encoded integer values
    public var coords: [Int64] = []

    public var geometries: [Geojson.Geometry] = []

    public var values: [Geojson.Value] = []

    public var customProperties: [UInt32] = []

    public init() {}

    public init(type: Geojson.Geometry.TypeEnum = Geojson.Geometry.TypeEnum.point,
      lengths: [UInt32] = [],
      coords: [Int64] = [],
      geometries: [Geojson.Geometry] = [],
      values: [Geojson.Value] = [],
      customProperties: [UInt32] = [])
    {
      self.type = type
      if !lengths.isEmpty {
        self.lengths = lengths
      }
      if !coords.isEmpty {
        self.coords = coords
      }
      if !geometries.isEmpty {
        self.geometries = geometries
      }
      if !values.isEmpty {
        self.values = values
      }
      if !customProperties.isEmpty {
        self.customProperties = customProperties
      }
    }

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeRequiredField(fieldType: Geojson.Geometry.TypeEnum.self, value: &type)
      case 2: handled = try setter.decodePackedField(fieldType: ProtobufUInt32.self, value: &lengths)
      case 3: handled = try setter.decodePackedField(fieldType: ProtobufSInt64.self, value: &coords)
      case 4: handled = try setter.decodeRepeatedMessageField(fieldType: Geojson.Geometry.self, value: &geometries)
      case 13: handled = try setter.decodeRepeatedMessageField(fieldType: Geojson.Value.self, value: &values)
      case 15: handled = try setter.decodePackedField(fieldType: ProtobufUInt32.self, value: &customProperties)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      try visitor.visitSingularField(fieldType: Geojson.Geometry.TypeEnum.self, value: type, protoFieldNumber: 1, protoFieldName: "type", jsonFieldName: "type", swiftFieldName: "type")
      if !lengths.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufUInt32.self, value: lengths, protoFieldNumber: 2, protoFieldName: "lengths", jsonFieldName: "lengths", swiftFieldName: "lengths")
      }
      if !coords.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufSInt64.self, value: coords, protoFieldNumber: 3, protoFieldName: "coords", jsonFieldName: "coords", swiftFieldName: "coords")
      }
      if !geometries.isEmpty {
        try visitor.visitRepeatedMessageField(value: geometries, protoFieldNumber: 4, protoFieldName: "geometries", jsonFieldName: "geometries", swiftFieldName: "geometries")
      }
      if !values.isEmpty {
        try visitor.visitRepeatedMessageField(value: values, protoFieldNumber: 13, protoFieldName: "values", jsonFieldName: "values", swiftFieldName: "values")
      }
      if !customProperties.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufUInt32.self, value: customProperties, protoFieldNumber: 15, protoFieldName: "custom_properties", jsonFieldName: "customProperties", swiftFieldName: "customProperties")
      }
      unknown.traverse(visitor: &visitor)
    }

    public func _protoc_generated_isEqualTo(other: Geojson.Geometry) -> Bool {
      if type != other.type {return false}
      if lengths != other.lengths {return false}
      if coords != other.coords {return false}
      if geometries != other.geometries {return false}
      if values != other.values {return false}
      if customProperties != other.customProperties {return false}
      if unknown != other.unknown {return false}
      return true
    }
  }

  public struct FeatureCollection: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Geojson.FeatureCollection"}
    public var protoMessageName: String {return "FeatureCollection"}
    public var protoPackageName: String {return ""}
    public var jsonFieldNames: [String: Int] {return [
      "features": 1,
      "values": 13,
      "customProperties": 15,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "features": 1,
      "values": 13,
      "custom_properties": 15,
    ]}

    var unknown = ProtobufUnknownStorage()

    public var features: [Geojson.Feature] = []

    public var values: [Geojson.Value] = []

    public var customProperties: [UInt32] = []

    public init() {}

    public init(features: [Geojson.Feature] = [],
      values: [Geojson.Value] = [],
      customProperties: [UInt32] = [])
    {
      if !features.isEmpty {
        self.features = features
      }
      if !values.isEmpty {
        self.values = values
      }
      if !customProperties.isEmpty {
        self.customProperties = customProperties
      }
    }

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Geojson.Feature.self, value: &features)
      case 13: handled = try setter.decodeRepeatedMessageField(fieldType: Geojson.Value.self, value: &values)
      case 15: handled = try setter.decodePackedField(fieldType: ProtobufUInt32.self, value: &customProperties)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      if !features.isEmpty {
        try visitor.visitRepeatedMessageField(value: features, protoFieldNumber: 1, protoFieldName: "features", jsonFieldName: "features", swiftFieldName: "features")
      }
      if !values.isEmpty {
        try visitor.visitRepeatedMessageField(value: values, protoFieldNumber: 13, protoFieldName: "values", jsonFieldName: "values", swiftFieldName: "values")
      }
      if !customProperties.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufUInt32.self, value: customProperties, protoFieldNumber: 15, protoFieldName: "custom_properties", jsonFieldName: "customProperties", swiftFieldName: "customProperties")
      }
      unknown.traverse(visitor: &visitor)
    }

    public func _protoc_generated_isEqualTo(other: Geojson.FeatureCollection) -> Bool {
      if features != other.features {return false}
      if values != other.values {return false}
      if customProperties != other.customProperties {return false}
      if unknown != other.unknown {return false}
      return true
    }
  }

  public struct Value: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Geojson.Value"}
    public var protoMessageName: String {return "Value"}
    public var protoPackageName: String {return ""}
    public var jsonFieldNames: [String: Int] {return [
      "stringValue": 1,
      "doubleValue": 2,
      "posIntValue": 3,
      "negIntValue": 4,
      "boolValue": 5,
      "jsonValue": 6,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "string_value": 1,
      "double_value": 2,
      "pos_int_value": 3,
      "neg_int_value": 4,
      "bool_value": 5,
      "json_value": 6,
    ]}

    var unknown = ProtobufUnknownStorage()

    public enum OneOf_ValueType: ExpressibleByNilLiteral, ProtobufOneofEnum {
      case stringValue(String)
      case doubleValue(Double)
      case posIntValue(UInt64)
      case negIntValue(UInt64)
      case boolValue(Bool)
      case jsonValue(String)
      case None

      public init(nilLiteral: ()) {
        self = .None
      }

      public init() {
        self = .None
      }

      public mutating func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        if self != .None && setter.rejectConflictingOneof {
          throw ProtobufDecodingError.duplicatedOneOf
        }
        let handled: Bool
        switch protoFieldNumber {
        case 1:
          var value: String?
          handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &value)
          if let value = value, handled {
            self = .stringValue(value)
          }
        case 2:
          var value: Double?
          handled = try setter.decodeOptionalField(fieldType: ProtobufDouble.self, value: &value)
          if let value = value, handled {
            self = .doubleValue(value)
          }
        case 3:
          var value: UInt64?
          handled = try setter.decodeOptionalField(fieldType: ProtobufUInt64.self, value: &value)
          if let value = value, handled {
            self = .posIntValue(value)
          }
        case 4:
          var value: UInt64?
          handled = try setter.decodeOptionalField(fieldType: ProtobufUInt64.self, value: &value)
          if let value = value, handled {
            self = .negIntValue(value)
          }
        case 5:
          var value: Bool?
          handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &value)
          if let value = value, handled {
            self = .boolValue(value)
          }
        case 6:
          var value: String?
          handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &value)
          if let value = value, handled {
            self = .jsonValue(value)
          }
        default:
          handled = false
          self = .None
        }
        return handled
      }

      public func traverse(visitor: inout ProtobufVisitor, start: Int, end: Int) throws {
        switch self {
        case .stringValue(let v):
          if start <= 1 && 1 < end {
            try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "string_value", jsonFieldName: "stringValue", swiftFieldName: "stringValue")
          }
        case .doubleValue(let v):
          if start <= 2 && 2 < end {
            try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: v, protoFieldNumber: 2, protoFieldName: "double_value", jsonFieldName: "doubleValue", swiftFieldName: "doubleValue")
          }
        case .posIntValue(let v):
          if start <= 3 && 3 < end {
            try visitor.visitSingularField(fieldType: ProtobufUInt64.self, value: v, protoFieldNumber: 3, protoFieldName: "pos_int_value", jsonFieldName: "posIntValue", swiftFieldName: "posIntValue")
          }
        case .negIntValue(let v):
          if start <= 4 && 4 < end {
            try visitor.visitSingularField(fieldType: ProtobufUInt64.self, value: v, protoFieldNumber: 4, protoFieldName: "neg_int_value", jsonFieldName: "negIntValue", swiftFieldName: "negIntValue")
          }
        case .boolValue(let v):
          if start <= 5 && 5 < end {
            try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 5, protoFieldName: "bool_value", jsonFieldName: "boolValue", swiftFieldName: "boolValue")
          }
        case .jsonValue(let v):
          if start <= 6 && 6 < end {
            try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 6, protoFieldName: "json_value", jsonFieldName: "jsonValue", swiftFieldName: "jsonValue")
          }
        case .None:
          break
        }
      }
    }

    public var stringValue: String? {
      get {
        if case .stringValue(let v) = valueType {
          return v
        }
        return nil
      }
      set {
        if let newValue = newValue {
          valueType = .stringValue(newValue)
        } else {
          valueType = .None
        }
      }
    }

    public var valueType: Geojson.Value.OneOf_ValueType = .None

    public var doubleValue: Double? {
      get {
        if case .doubleValue(let v) = valueType {
          return v
        }
        return nil
      }
      set {
        if let newValue = newValue {
          valueType = .doubleValue(newValue)
        } else {
          valueType = .None
        }
      }
    }

    public var posIntValue: UInt64? {
      get {
        if case .posIntValue(let v) = valueType {
          return v
        }
        return nil
      }
      set {
        if let newValue = newValue {
          valueType = .posIntValue(newValue)
        } else {
          valueType = .None
        }
      }
    }

    public var negIntValue: UInt64? {
      get {
        if case .negIntValue(let v) = valueType {
          return v
        }
        return nil
      }
      set {
        if let newValue = newValue {
          valueType = .negIntValue(newValue)
        } else {
          valueType = .None
        }
      }
    }

    public var boolValue: Bool? {
      get {
        if case .boolValue(let v) = valueType {
          return v
        }
        return nil
      }
      set {
        if let newValue = newValue {
          valueType = .boolValue(newValue)
        } else {
          valueType = .None
        }
      }
    }

    public var jsonValue: String? {
      get {
        if case .jsonValue(let v) = valueType {
          return v
        }
        return nil
      }
      set {
        if let newValue = newValue {
          valueType = .jsonValue(newValue)
        } else {
          valueType = .None
        }
      }
    }

    public init() {}

    public init(stringValue: String? = nil,
      doubleValue: Double? = nil,
      posIntValue: UInt64? = nil,
      negIntValue: UInt64? = nil,
      boolValue: Bool? = nil,
      jsonValue: String? = nil)
    {
      if let v = stringValue {
        self.valueType = .stringValue(v)
      }
      if let v = doubleValue {
        self.valueType = .doubleValue(v)
      }
      if let v = posIntValue {
        self.valueType = .posIntValue(v)
      }
      if let v = negIntValue {
        self.valueType = .negIntValue(v)
      }
      if let v = boolValue {
        self.valueType = .boolValue(v)
      }
      if let v = jsonValue {
        self.valueType = .jsonValue(v)
      }
    }

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1, 2, 3, 4, 5, 6:
        handled = try valueType.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      try valueType.traverse(visitor: &visitor, start: 1, end: 7)
      unknown.traverse(visitor: &visitor)
    }

    public func _protoc_generated_isEqualTo(other: Geojson.Value) -> Bool {
      if valueType != other.valueType {return false}
      if unknown != other.unknown {return false}
      return true
    }
  }

  ///   global arrays of unique keys
  public var keys: [String] {
    get {return _storage._keys}
    set {_uniqueStorage()._keys = newValue}
  }

  ///   max coordinate dimensions
  public var dimensions: UInt32? {
    get {return _storage._dimensions ?? 2}
    set {_uniqueStorage()._dimensions = newValue}
  }

  ///   number of digits after decimal point for coordinates
  public var precision: UInt32? {
    get {return _storage._precision ?? 6}
    set {_uniqueStorage()._precision = newValue}
  }

  public var featureCollection: Geojson.FeatureCollection? {
    get {
      if case .featureCollection(let v) = _storage._dataType {
        return v
      }
      return nil
    }
    set {
      if let newValue = newValue {
        _uniqueStorage()._dataType = .featureCollection(newValue)
      } else {
        _uniqueStorage()._dataType = .None
      }
    }
  }

  public var feature: Geojson.Feature? {
    get {
      if case .feature(let v) = _storage._dataType {
        return v
      }
      return nil
    }
    set {
      if let newValue = newValue {
        _uniqueStorage()._dataType = .feature(newValue)
      } else {
        _uniqueStorage()._dataType = .None
      }
    }
  }

  public var geometry: Geojson.Geometry? {
    get {
      if case .geometry(let v) = _storage._dataType {
        return v
      }
      return nil
    }
    set {
      if let newValue = newValue {
        _uniqueStorage()._dataType = .geometry(newValue)
      } else {
        _uniqueStorage()._dataType = .None
      }
    }
  }

  public var _dataType: OneOf_DataType {
    get {return _storage._dataType}
    set {
      _uniqueStorage()._dataType = newValue
    }
  }

  public init() {}

  public init(keys: [String] = [],
    dimensions: UInt32? = nil,
    precision: UInt32? = nil,
    featureCollection: Geojson.FeatureCollection? = nil,
    feature: Geojson.Feature? = nil,
    geometry: Geojson.Geometry? = nil)
  {
    let storage = _uniqueStorage()
    if !keys.isEmpty {
      storage._keys = keys
    }
    storage._dimensions = dimensions
    storage._precision = precision
    if let v = featureCollection {
      storage._dataType = .featureCollection(v)
    }
    if let v = feature {
      storage._dataType = .feature(v)
    }
    if let v = geometry {
      storage._dataType = .geometry(v)
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Geojson) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

public func ==(lhs: Geojson.OneOf_DataType, rhs: Geojson.OneOf_DataType) -> Bool {
  switch (lhs, rhs) {
  case (.featureCollection(let l), .featureCollection(let r)): return l == r
  case (.feature(let l), .feature(let r)): return l == r
  case (.geometry(let l), .geometry(let r)): return l == r
  case (.None, .None): return true
  default: return false
  }
}

public func ==(lhs: Geojson.Feature.OneOf_IdType, rhs: Geojson.Feature.OneOf_IdType) -> Bool {
  switch (lhs, rhs) {
  case (.id(let l), .id(let r)): return l == r
  case (.intId(let l), .intId(let r)): return l == r
  case (.None, .None): return true
  default: return false
  }
}

public func ==(lhs: Geojson.Value.OneOf_ValueType, rhs: Geojson.Value.OneOf_ValueType) -> Bool {
  switch (lhs, rhs) {
  case (.stringValue(let l), .stringValue(let r)): return l == r
  case (.doubleValue(let l), .doubleValue(let r)): return l == r
  case (.posIntValue(let l), .posIntValue(let r)): return l == r
  case (.negIntValue(let l), .negIntValue(let r)): return l == r
  case (.boolValue(let l), .boolValue(let r)): return l == r
  case (.jsonValue(let l), .jsonValue(let r)): return l == r
  case (.None, .None): return true
  default: return false
  }
}
